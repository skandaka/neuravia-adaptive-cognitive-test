<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NeuraVia - Adaptive Cognitive Test System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 18px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .card h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .question-display {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 150px;
        }

        .question-text {
            font-size: 18px;
            color: #333;
            margin-bottom: 15px;
        }

        .timer {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #5a67d8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .module-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .module-btn {
            flex: 1;
            padding: 15px;
            background: #f8f9fa;
            border: 2px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .module-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .graph-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 20px;
        }

        .graph-placeholder {
            text-align: center;
            color: #666;
        }

        .question-bank-info {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }

        .difficulty-1 { background: #4caf50; color: white; }
        .difficulty-2 { background: #ff9800; color: white; }
        .difficulty-3 { background: #f44336; color: white; }

        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .metric {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
        }

        .metric-label {
            font-size: 12px;
            color: #666;
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .code-section {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .tab-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab {
            padding: 10px 20px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
        }

        .tab.active {
            background: #1e1e1e;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>NeuraVia Adaptive Cognitive Test System</h1>
            <p class="subtitle">Multimodal Deep Learning Framework for Alzheimer's Disease Progression Prediction</p>
        </div>

        <div class="main-grid">
            <div class="card">
                <h2>Test Configuration</h2>
                
                <div class="question-bank-info">
                    <strong>Question Bank Status:</strong> 1,500 questions loaded
                    <br>
                    <small>500 questions per module, distributed across 3 difficulty levels</small>
                </div>

                <div class="module-selector">
                    <button class="module-btn active" onclick="selectModule('concentration')">
                        Concentration
                    </button>
                    <button class="module-btn" onclick="selectModule('calculation')">
                        Calculation
                    </button>
                    <button class="module-btn" onclick="selectModule('simulation')">
                        Simulation
                    </button>
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="currentModule">Concentration</div>
                        <div class="stat-label">Current Module</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="currentDifficulty">1</div>
                        <div class="stat-label">Difficulty Level</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="questionCount">0/10</div>
                        <div class="stat-label">Progress</div>
                    </div>
                </div>

                <div class="controls">
                    <button onclick="startTest()">Start Test</button>
                    <button onclick="generateQuestionBank()">Generate Questions</button>
                    <button onclick="showRGAT()">Show R-GAT Structure</button>
                    <button onclick="exportData()">Export Data</button>
                </div>
            </div>

            <div class="card">
                <h2>Adaptive Testing Interface</h2>
                
                <div class="question-display">
                    <div class="question-text" id="questionText">
                        Click "Start Test" to begin the adaptive cognitive assessment
                    </div>
                    <div class="timer" id="timer" style="display:none;">
                        Time: <span id="timeLeft">30</span>s
                    </div>
                </div>

                <div class="performance-metrics">
                    <div class="metric">
                        <div class="metric-label">Accuracy</div>
                        <div class="metric-value" id="accuracy">0%</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Avg Response Time</div>
                        <div class="metric-value" id="avgTime">0s</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Cognitive Score</div>
                        <div class="metric-value" id="cogScore">0</div>
                    </div>
                    <div class="metric">
                        <div class="metric-label">Adaptive Level</div>
                        <div class="metric-value" id="adaptLevel">Baseline</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>R-GAT Neural Network Structure</h2>
            <div class="graph-container" id="graphContainer">
                <div class="graph-placeholder">
                    <p>R-GAT (Relational Graph Attention Network) Visualization</p>
                    <p style="margin-top: 10px; font-size: 14px;">Click "Show R-GAT Structure" to visualize the neural network</p>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Implementation Code</h2>
            <div class="tab-container">
                <button class="tab active" onclick="showCode('questionBank')">Question Bank</button>
                <button class="tab" onclick="showCode('adaptive')">Adaptive Algorithm</button>
                <button class="tab" onclick="showCode('rgat')">R-GAT Structure</button>
                <button class="tab" onclick="showCode('api')">OpenAI Integration</button>
            </div>
            <div class="code-section" id="codeDisplay">
                <pre id="codeContent"></pre>
            </div>
        </div>
    </div>

    <script>
        // Global state management
        let currentState = {
            module: 'concentration',
            difficulty: 1,
            questionIndex: 0,
            score: 0,
            totalQuestions: 0,
            responses: [],
            timer: null,
            testActive: false,
            cognitiveSubscores: {
                concentration: [],
                calculation: [],
                simulation: []
            }
        };

        // Question Bank Structure (1,500 questions total)
        const questionBank = {
            concentration: {
                1: [], // Easy (167 questions)
                2: [], // Medium (167 questions)
                3: []  // Hard (166 questions)
            },
            calculation: {
                1: [], // Easy
                2: [], // Medium
                3: []  // Hard
            },
            simulation: {
                1: [], // Easy
                2: [], // Medium
                3: []  // Hard
            }
        };

        // Generate comprehensive question bank
        function generateQuestionBank() {
            // Concentration Questions
            const concentrationTemplates = {
                1: [
                    "Count the number of times the letter 'A' appears in this sentence: {sentence}",
                    "Which word appears twice in this list: {wordList}",
                    "Select all even numbers from: {numberList}",
                    "Identify the color that appears most frequently: {colorList}",
                    "Find the missing number in sequence: {sequence}"
                ],
                2: [
                    "Track the pattern and identify what comes next: {pattern}",
                    "Remember this sequence and repeat it backwards: {sequence}",
                    "Count vowels while ignoring consonants in: {text}",
                    "Identify all palindromes in this list: {wordList}",
                    "Find the two numbers that sum to {target} from: {numbers}"
                ],
                3: [
                    "Track multiple moving objects and identify which crossed paths: {scenario}",
                    "Memorize this grid pattern and identify changes: {grid}",
                    "Count specific patterns while ignoring distractors in: {complex}",
                    "Identify the logical inconsistency in this paragraph: {paragraph}",
                    "Track the sequence of events and identify the timeline: {events}"
                ]
            };

            const calculationTemplates = {
                1: [
                    "What is {num1} + {num2}?",
                    "Calculate {num1} - {num2}",
                    "What is {num1} × {num2}?",
                    "If you have {total} items and give away {give}, how many remain?",
                    "What is 10% of {number}?"
                ],
                2: [
                    "Calculate ({num1} + {num2}) × {num3}",
                    "What is the average of: {numbers}?",
                    "If something costs ${price} with {discount}% off, what's the final price?",
                    "Solve for x: {equation}",
                    "Calculate compound percentage: {scenario}"
                ],
                3: [
                    "Calculate the standard deviation of: {dataset}",
                    "Solve this system of equations: {equations}",
                    "What is the compound interest on ${principal} at {rate}% for {years} years?",
                    "Calculate the probability of: {probability_scenario}",
                    "Optimize this function: {function}"
                ]
            };

            const simulationTemplates = {
                1: [
                    "You're at a new grocery store. How would you find the dairy section?",
                    "Your regular route to work is blocked. What do you do?",
                    "You need to cook dinner but are missing one ingredient. How do you adapt?",
                    "You're meeting someone at an unfamiliar location. How do you prepare?",
                    "Your phone battery is at 5%. Prioritize your remaining tasks."
                ],
                2: [
                    "You're managing a team project with conflicting deadlines. How do you prioritize?",
                    "You discover a billing error on your account. Outline your resolution steps.",
                    "Plan an efficient route visiting 5 locations with time constraints: {locations}",
                    "You're mediating a disagreement between colleagues. What's your approach?",
                    "Design a backup plan for a critical presentation if technology fails."
                ],
                3: [
                    "You're evacuating a building with 50 people. Design the evacuation strategy.",
                    "Allocate limited resources across competing priorities: {resource_scenario}",
                    "Navigate a complex medical decision with incomplete information: {medical_scenario}",
                    "Design a crisis communication plan for: {crisis_scenario}",
                    "Solve this ethical dilemma with multiple stakeholders: {ethical_scenario}"
                ]
            };

            // Generate questions for each module and difficulty
            for (let module in questionBank) {
                for (let diff = 1; diff <= 3; diff++) {
                    const count = diff === 3 ? 166 : 167;
                    const templates = module === 'concentration' ? concentrationTemplates :
                                    module === 'calculation' ? calculationTemplates : simulationTemplates;
                    
                    for (let i = 0; i < count; i++) {
                        const templateList = templates[diff];
                        const template = templateList[i % templateList.length];
                        
                        questionBank[module][diff].push({
                            id: `${module}_${diff}_${i}`,
                            text: generateQuestionFromTemplate(template, module, diff),
                            difficulty: diff,
                            module: module,
                            timeLimit: diff === 1 ? 30 : diff === 2 ? 45 : 60,
                            points: diff * 10
                        });
                    }
                }
            }

            alert('Question bank generated successfully! 1,500 questions created.');
            console.log('Question Bank Structure:', questionBank);
        }

        function generateQuestionFromTemplate(template, module, difficulty) {
            // Simplified template filling for demonstration
            let question = template;
            
            // Replace placeholders with random values
            question = question.replace(/{num1}/g, Math.floor(Math.random() * 100));
            question = question.replace(/{num2}/g, Math.floor(Math.random() * 100));
            question = question.replace(/{num3}/g, Math.floor(Math.random() * 10));
            question = question.replace(/{number}/g, Math.floor(Math.random() * 1000));
            question = question.replace(/{total}/g, Math.floor(Math.random() * 100));
            question = question.replace(/{give}/g, Math.floor(Math.random() * 50));
            question = question.replace(/{price}/g, (Math.random() * 1000).toFixed(2));
            question = question.replace(/{discount}/g, Math.floor(Math.random() * 50));
            question = question.replace(/{target}/g, Math.floor(Math.random() * 200));
            
            // Add more complex replacements as needed
            question = question.replace(/{sentence}/g, "The quick brown fox jumps over the lazy dog");
            question = question.replace(/{wordList}/g, "apple, banana, orange, apple, grape");
            question = question.replace(/{numberList}/g, "2, 5, 8, 11, 14, 17, 20");
            question = question.replace(/{sequence}/g, "2, 4, 8, 16, ?");
            
            return question;
        }

        // R-GAT Neural Network Implementation
        class RGAT {
            constructor() {
                this.nodes = [];
                this.edges = [];
                this.attentionWeights = {};
            }

            addNode(id, features) {
                this.nodes.push({
                    id: id,
                    features: features,
                    embedding: null
                });
            }

            addEdge(source, target, weight) {
                this.edges.push({
                    source: source,
                    target: target,
                    weight: weight
                });
            }

            computeAttention(sourceFeatures, targetFeatures) {
                // Simplified attention mechanism
                const dotProduct = sourceFeatures.reduce((sum, val, i) => 
                    sum + val * targetFeatures[i], 0);
                return Math.tanh(dotProduct);
            }

            forward() {
                // Compute attention weights for all edges
                this.edges.forEach(edge => {
                    const sourceNode = this.nodes.find(n => n.id === edge.source);
                    const targetNode = this.nodes.find(n => n.id === edge.target);
                    
                    const attention = this.computeAttention(
                        sourceNode.features,
                        targetNode.features
                    );
                    
                    this.attentionWeights[`${edge.source}-${edge.target}`] = attention;
                });

                // Update node embeddings based on attention
                this.nodes.forEach(node => {
                    const incomingEdges = this.edges.filter(e => e.target === node.id);
                    
                    if (incomingEdges.length > 0) {
                        const aggregated = new Array(node.features.length).fill(0);
                        
                        incomingEdges.forEach(edge => {
                            const sourceNode = this.nodes.find(n => n.id === edge.source);
                            const attention = this.attentionWeights[`${edge.source}-${edge.target}`];
                            
                            sourceNode.features.forEach((val, i) => {
                                aggregated[i] += val * attention;
                            });
                        });
                        
                        node.embedding = aggregated.map(val => Math.tanh(val));
                    } else {
                        node.embedding = node.features;
                    }
                });

                return this.nodes.map(n => n.embedding);
            }
        }

        // Adaptive Question Selection Algorithm
        class AdaptiveSelector {
            constructor() {
                this.performanceHistory = [];
                this.difficultyAdjustmentThreshold = 0.7;
                this.windowSize = 3;
            }

            selectNextQuestion(currentDifficulty, recentPerformance, availableQuestions) {
                const avgPerformance = this.calculateRecentPerformance(recentPerformance);
                
                let nextDifficulty = currentDifficulty;
                
                // Adaptive difficulty adjustment
                if (avgPerformance > 0.8 && currentDifficulty < 3) {
                    nextDifficulty = currentDifficulty + 1;
                } else if (avgPerformance < 0.4 && currentDifficulty > 1) {
                    nextDifficulty = currentDifficulty - 1;
                }

                // Select question from appropriate difficulty pool
                const questionPool = availableQuestions[nextDifficulty];
                const randomIndex = Math.floor(Math.random() * questionPool.length);
                
                return {
                    question: questionPool[randomIndex],
                    difficulty: nextDifficulty
                };
            }

            calculateRecentPerformance(responses) {
                if (responses.length === 0) return 0.5;
                
                const recent = responses.slice(-this.windowSize);
                const correctCount = recent.filter(r => r.correct).length;
                
                return correctCount / recent.length;
            }

            updatePerformanceModel(response) {
                this.performanceHistory.push(response);
                
                // Implement more sophisticated modeling here
                // Could include response time, confidence, patterns, etc.
            }
        }

        // Initialize components
        const rgat = new RGAT();
        const adaptiveSelector = new AdaptiveSelector();

        // UI Functions
        function selectModule(module) {
            currentState.module = module;
            document.getElementById('currentModule').textContent = 
                module.charAt(0).toUpperCase() + module.slice(1);
            
            // Update active button
            document.querySelectorAll('.module-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function startTest() {
            if (questionBank[currentState.module][1].length === 0) {
                alert('Please generate the question bank first!');
                generateQuestionBank();
                return;
            }

            currentState.testActive = true;
            currentState.questionIndex = 0;
            currentState.score = 0;
            currentState.responses = [];
            
            displayNextQuestion();
        }

        function displayNextQuestion() {
            const questions = questionBank[currentState.module];
            const nextQ = adaptiveSelector.selectNextQuestion(
                currentState.difficulty,
                currentState.responses,
                questions
            );

            if (nextQ.question) {
                document.getElementById('questionText').textContent = nextQ.question.text;
                document.getElementById('currentDifficulty').textContent = nextQ.difficulty;
                currentState.difficulty = nextQ.difficulty;
                
                startTimer(nextQ.question.timeLimit);
                
                currentState.questionIndex++;
                document.getElementById('questionCount').textContent = 
                    `${currentState.questionIndex}/10`;
            }
        }

        function startTimer(seconds) {
            let timeLeft = seconds;
            document.getElementById('timer').style.display = 'inline-block';
            document.getElementById('timeLeft').textContent = timeLeft;

            if (currentState.timer) {
                clearInterval(currentState.timer);
            }

            currentState.timer = setInterval(() => {
                timeLeft--;
                document.getElementById('timeLeft').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(currentState.timer);
                    handleTimeout();
                }
            }, 1000);
        }

        function handleTimeout() {
            // Handle question timeout
            currentState.responses.push({
                correct: false,
                timeout: true,
                difficulty: currentState.difficulty
            });

            if (currentState.questionIndex < 10) {
                displayNextQuestion();
            } else {
                completeTest();
            }
        }

        function completeTest() {
            currentState.testActive = false;
            clearInterval(currentState.timer);
            
            // Calculate final scores
            const accuracy = (currentState.score / currentState.questionIndex) * 100;
            document.getElementById('accuracy').textContent = accuracy.toFixed(1) + '%';
            
            // Update cognitive subscores
            currentState.cognitiveSubscores[currentState.module].push({
                timestamp: new Date().toISOString(),
                score: currentState.score,
                accuracy: accuracy,
                responses: currentState.responses
            });

            alert(`Test completed! Accuracy: ${accuracy.toFixed(1)}%`);
        }

        function showRGAT() {
            // Initialize R-GAT with cognitive data
            rgat.nodes = [];
            rgat.edges = [];
            
            // Add nodes for cognitive subdomains
            rgat.addNode('concentration', [0.8, 0.6, 0.7, 0.9]);
            rgat.addNode('calculation', [0.7, 0.8, 0.6, 0.8]);
            rgat.addNode('simulation', [0.6, 0.7, 0.9, 0.7]);
            rgat.addNode('memory', [0.7, 0.6, 0.8, 0.8]);
            rgat.addNode('attention', [0.8, 0.7, 0.7, 0.9]);
            
            // Add edges with correlations
            rgat.addEdge('concentration', 'attention', 0.9);
            rgat.addEdge('concentration', 'memory', 0.7);
            rgat.addEdge('calculation', 'concentration', 0.6);
            rgat.addEdge('simulation', 'memory', 0.8);
            rgat.addEdge('attention', 'simulation', 0.7);
            
            // Compute forward pass
            const embeddings = rgat.forward();
            
            // Visualize
            const graphHTML = `
                <svg width="600" height="400" viewBox="0 0 600 400">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                         refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#667eea" />
                        </marker>
                    </defs>
                    
                    <!-- Nodes -->
                    <circle cx="150" cy="100" r="40" fill="#667eea" opacity="0.8"/>
                    <text x="150" y="105" text-anchor="middle" fill="white">Concentration</text>
                    
                    <circle cx="450" cy="100" r="40" fill="#667eea" opacity="0.8"/>
                    <text x="450" y="105" text-anchor="middle" fill="white">Calculation</text>
                    
                    <circle cx="300" cy="200" r="40" fill="#667eea" opacity="0.8"/>
                    <text x="300" y="205" text-anchor="middle" fill="white">Memory</text>
                    
                    <circle cx="150" cy="300" r="40" fill="#667eea" opacity="0.8"/>
                    <text x="150" y="305" text-anchor="middle" fill="white">Simulation</text>
                    
                    <circle cx="450" cy="300" r="40" fill="#667eea" opacity="0.8"/>
                    <text x="450" y="305" text-anchor="middle" fill="white">Attention</text>
                    
                    <!-- Edges -->
                    <line x1="190" y1="100" x2="260" y2="180" stroke="#667eea" stroke-width="2" 
                          marker-end="url(#arrowhead)" opacity="0.6"/>
                    <line x1="190" y1="120" x2="410" y2="280" stroke="#667eea" stroke-width="2" 
                          marker-end="url(#arrowhead)" opacity="0.6"/>
                    <line x1="410" y1="100" x2="190" y2="100" stroke="#667eea" stroke-width="2" 
                          marker-end="url(#arrowhead)" opacity="0.6"/>
                    <line x1="190" y1="280" x2="260" y2="220" stroke="#667eea" stroke-width="2" 
                          marker-end="url(#arrowhead)" opacity="0.6"/>
                    <line x1="410" y1="280" x2="190" y2="120" stroke="#667eea" stroke-width="2" 
                          marker-end="url(#arrowhead)" opacity="0.6"/>
                </svg>
                <div style="margin-top: 20px;">
                    <strong>R-GAT Output Embeddings:</strong>
                    <pre>${JSON.stringify(embeddings, null, 2)}</pre>
                </div>
            `;
            
            document.getElementById('graphContainer').innerHTML = graphHTML;
        }

        function exportData() {
            const exportData = {
                questionBank: questionBank,
                cognitiveSubscores: currentState.cognitiveSubscores,
                rgatStructure: {
                    nodes: rgat.nodes,
                    edges: rgat.edges,
                    attentionWeights: rgat.attentionWeights
                },
                timestamp: new Date().toISOString()
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `neuravia_cognitive_test_${Date.now()}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        function showCode(section) {
            // Update active tab
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            let code = '';
            
            if (section === 'questionBank') {
                code = `# Question Bank Generation with OpenAI API Integration
import openai
import json
import numpy as np
from typing import Dict, List, Tuple

class QuestionBankGenerator:
    """Generate 1,500 adaptive questions for Alzheimer's cognitive testing"""
    
    def __init__(self, api_key: str):
        openai.api_key = api_key
        self.question_bank = {
            'concentration': {1: [], 2: [], 3: []},
            'calculation': {1: [], 2: [], 3: []},
            'simulation': {1: [], 2: [], 3: []}
        }
        
    def generate_questions(self, module: str, difficulty: int, count: int) -> List[Dict]:
        """Generate questions using GPT-4 API"""
        
        prompts = {
            'concentration': {
                1: "Generate easy attention/focus tasks suitable for cognitive assessment",
                2: "Generate medium-difficulty pattern recognition and attention tasks",
                3: "Generate complex multi-tracking and attention division tasks"
            },
            'calculation': {
                1: "Generate simple arithmetic problems (addition, subtraction)",
                2: "Generate moderate math problems (multiplication, percentages)",
                3: "Generate complex calculations (statistics, compound interest)"
            },
            'simulation': {
                1: "Generate simple daily life decision scenarios",
                2: "Generate moderate problem-solving scenarios",
                3: "Generate complex crisis management scenarios"
            }
        }
        
        questions = []
        batch_size = 10
        
        for i in range(0, count, batch_size):
            response = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[
                    {"role": "system", "content": "You are a cognitive assessment expert."},
                    {"role": "user", "content": f"{prompts[module][difficulty]}. Generate {batch_size} unique questions with time limits."}
                ],
                temperature=0.8,
                max_tokens=2000
            )
            
            # Parse and structure questions
            batch_questions = self._parse_questions(
                response.choices[0].message.content,
                module, 
                difficulty
            )
            questions.extend(batch_questions)
            
        return questions[:count]
    
    def _parse_questions(self, raw_text: str, module: str, difficulty: int) -> List[Dict]:
        """Parse GPT output into structured question format"""
        questions = []
        
        # Split and process raw text into questions
        lines = raw_text.strip().split('\\n')
        
        for i, line in enumerate(lines):
            if line.strip():
                questions.append({
                    'id': f"{module}_{difficulty}_{i}",
                    'text': line.strip(),
                    'module': module,
                    'difficulty': difficulty,
                    'timeLimit': 30 * difficulty,  # 30s, 60s, 90s
                    'points': 10 * difficulty
                })
        
        return questions
    
    def generate_full_bank(self):
        """Generate all 1,500 questions"""
        for module in self.question_bank.keys():
            for difficulty in [1, 2, 3]:
                count = 166 if difficulty == 3 else 167
                questions = self.generate_questions(module, difficulty, count)
                self.question_bank[module][difficulty] = questions
                
        return self.question_bank
    
    def export_to_json(self, filename: str):
        """Export question bank to JSON file"""
        with open(filename, 'w') as f:
            json.dump(self.question_bank, f, indent=2)
    
    def import_to_database(self, db_connection):
        """Import questions to database for API access"""
        cursor = db_connection.cursor()
        
        for module, difficulties in self.question_bank.items():
            for difficulty, questions in difficulties.items():
                for q in questions:
                    cursor.execute("""
                        INSERT INTO questions (id, module, difficulty, text, time_limit, points)
                        VALUES (?, ?, ?, ?, ?, ?)
                    """, (q['id'], q['module'], q['difficulty'], 
                          q['text'], q['timeLimit'], q['points']))
        
        db_connection.commit()`;
            } else if (section === 'adaptive') {
                code = `# Adaptive Question Selection Algorithm
import numpy as np
from typing import List, Dict, Tuple, Optional
from collections import deque
import torch
import torch.nn as nn

class AdaptiveTestingEngine:
    """Reinforcement Learning-based adaptive testing system"""
    
    def __init__(self, window_size: int = 3):
        self.window_size = window_size
        self.performance_history = deque(maxlen=100)
        self.difficulty_transitions = np.array([
            [0.6, 0.3, 0.1],  # From easy
            [0.3, 0.4, 0.3],  # From medium
            [0.1, 0.3, 0.6]   # From hard
        ])
        self.rl_model = QuestionSelectionRL()
        
    def select_next_question(self, 
                            current_difficulty: int,
                            recent_responses: List[Dict],
                            available_questions: Dict[int, List]) -> Tuple[Dict, int]:
        """Select optimal next question using RL policy"""
        
        # Calculate performance metrics
        performance = self._calculate_performance_metrics(recent_responses)
        
        # Get state representation
        state = self._get_state_representation(
            current_difficulty, 
            performance, 
            recent_responses
        )
        
        # Use RL model to predict next difficulty
        next_difficulty = self.rl_model.predict_action(state)
        
        # Apply adaptive rules
        next_difficulty = self._apply_adaptive_rules(
            current_difficulty, 
            performance, 
            next_difficulty
        )
        
        # Select question from pool
        question_pool = available_questions[next_difficulty]
        
        # Use item response theory for selection
        question = self._select_by_irt(
            question_pool, 
            performance['ability_estimate']
        )
        
        return question, next_difficulty
    
    def _calculate_performance_metrics(self, responses: List[Dict]) -> Dict:
        """Calculate comprehensive performance metrics"""
        
        if not responses:
            return {
                'accuracy': 0.5,
                'avg_time': 30,
                'consistency': 1.0,
                'ability_estimate': 0.0,
                'trend': 0
            }
        
        recent = responses[-self.window_size:]
        
        # Basic metrics
        correct = sum(1 for r in recent if r.get('correct', False))
        accuracy = correct / len(recent)
        
        # Response time analysis
        times = [r.get('time', 30) for r in recent]
        avg_time = np.mean(times)
        time_consistency = 1 - (np.std(times) / np.mean(times) if np.mean(times) > 0 else 0)
        
        # Ability estimation (simplified IRT)
        ability = self._estimate_ability(responses)
        
        # Performance trend
        if len(responses) >= 2:
            recent_acc = accuracy
            prev_acc = sum(1 for r in responses[-2*self.window_size:-self.window_size] 
                          if r.get('correct', False)) / self.window_size
            trend = recent_acc - prev_acc
        else:
            trend = 0
        
        return {
            'accuracy': accuracy,
            'avg_time': avg_time,
            'consistency': time_consistency,
            'ability_estimate': ability,
            'trend': trend
        }
    
    def _estimate_ability(self, responses: List[Dict]) -> float:
        """Estimate cognitive ability using Item Response Theory"""
        
        if not responses:
            return 0.0
        
        # Simplified 1-parameter IRT model
        difficulties = [r.get('difficulty', 1) for r in responses]
        correct = [1 if r.get('correct', False) else 0 for r in responses]
        
        # Maximum likelihood estimation
        ability = 0.0
        for _ in range(10):  # Newton-Raphson iterations
            probabilities = [1 / (1 + np.exp(-(ability - d))) for d in difficulties]
            
            # First derivative
            d1 = sum(c - p for c, p in zip(correct, probabilities))
            
            # Second derivative
            d2 = -sum(p * (1 - p) for p in probabilities)
            
            if abs(d2) > 0.001:
                ability = ability - d1 / d2
            
        return np.clip(ability, -3, 3)
    
    def _apply_adaptive_rules(self, 
                              current: int, 
                              performance: Dict, 
                              predicted: int) -> int:
        """Apply rule-based constraints to RL predictions"""
        
        # Prevent too rapid difficulty changes
        if abs(predicted - current) > 1:
            predicted = current + np.sign(predicted - current)
        
        # Performance-based overrides
        if performance['accuracy'] > 0.9 and current < 3:
            return min(current + 1, 3)
        elif performance['accuracy'] < 0.3 and current > 1:
            return max(current - 1, 1)
        
        # Consistency check
        if performance['consistency'] < 0.5:
            return current  # Stay at current level if inconsistent
        
        return predicted
    
    def _select_by_irt(self, pool: List[Dict], ability: float) -> Dict:
        """Select question with maximum information at ability level"""
        
        max_info = -1
        selected = None
        
        for question in pool:
            # Calculate information function
            diff = question.get('difficulty', 2)
            prob = 1 / (1 + np.exp(-(ability - diff)))
            info = prob * (1 - prob)  # Information at ability level
            
            if info > max_info:
                max_info = info
                selected = question
        
        return selected or pool[0]
    
    def _get_state_representation(self, 
                                  difficulty: int, 
                                  performance: Dict,
                                  responses: List[Dict]) -> np.ndarray:
        """Create state vector for RL model"""
        
        state = np.zeros(10)
        
        # Current difficulty (one-hot)
        state[difficulty - 1] = 1
        
        # Performance metrics
        state[3] = performance['accuracy']
        state[4] = performance['avg_time'] / 60  # Normalized
        state[5] = performance['consistency']
        state[6] = performance['ability_estimate'] / 3  # Normalized
        state[7] = performance['trend']
        
        # Response pattern features
        if responses:
            state[8] = len(responses) / 10  # Progress
            state[9] = np.std([r.get('difficulty', 1) for r in responses[-5:]])
        
        return state


class QuestionSelectionRL(nn.Module):
    """Deep Q-Network for question selection"""
    
    def __init__(self, state_dim: int = 10, action_dim: int = 3):
        super().__init__()
        self.fc1 = nn.Linear(state_dim, 64)
        self.fc2 = nn.Linear(64, 32)
        self.fc3 = nn.Linear(32, action_dim)
        
    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        return self.fc3(x)
    
    def predict_action(self, state: np.ndarray) -> int:
        """Predict next difficulty level"""
        with torch.no_grad():
            state_tensor = torch.FloatTensor(state).unsqueeze(0)
            q_values = self.forward(state_tensor)
            return q_values.argmax().item() + 1  # Convert to difficulty (1-3)`;
            } else if (section === 'rgat') {
                code = `# R-GAT Neural Network Implementation
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn import GATConv
import numpy as np
from typing import List, Tuple, Dict

class RGAT(nn.Module):
    """Relational Graph Attention Network for cognitive score analysis"""
    
    def __init__(self, 
                 in_features: int = 4,
                 hidden_features: int = 64,
                 out_features: int = 32,
                 num_heads: int = 8,
                 num_relations: int = 5):
        super(RGAT, self).__init__()
        
        self.num_relations = num_relations
        
        # Multi-head attention layers for each relation type
        self.attention_layers = nn.ModuleList([
            GATConv(in_features, hidden_features, heads=num_heads, concat=True)
            for _ in range(num_relations)
        ])
        
        # Relation-specific transformations
        self.relation_transforms = nn.ModuleList([
            nn.Linear(in_features, in_features)
            for _ in range(num_relations)
        ])
        
        # Output layers
        self.fc1 = nn.Linear(hidden_features * num_heads * num_relations, hidden_features)
        self.fc2 = nn.Linear(hidden_features, out_features)
        self.dropout = nn.Dropout(0.2)
        
        # Attention weight computation
        self.attention_mlp = nn.Sequential(
            nn.Linear(2 * in_features, 64),
            nn.ReLU(),
            nn.Linear(64, 1),
            nn.Sigmoid()
        )
    
    def forward(self, x: torch.Tensor, edge_index: torch.Tensor, 
                edge_type: torch.Tensor) -> torch.Tensor:
        """
        Forward pass through R-GAT
        
        Args:
            x: Node features [num_nodes, in_features]
            edge_index: Edge connectivity [2, num_edges]
            edge_type: Relation type for each edge [num_edges]
        """
        
        # Separate edges by relation type
        relation_outputs = []
        
        for rel in range(self.num_relations):
            # Get edges for this relation
            rel_mask = edge_type == rel
            rel_edges = edge_index[:, rel_mask]
            
            if rel_edges.shape[1] > 0:
                # Apply relation-specific transformation
                x_transformed = self.relation_transforms[rel](x)
                
                # Apply GAT for this relation
                out = self.attention_layers[rel](x_transformed, rel_edges)
                relation_outputs.append(out)
            else:
                # No edges for this relation, use zero tensor
                relation_outputs.append(
                    torch.zeros(x.shape[0], 
                               self.attention_layers[rel].out_channels * self.attention_layers[rel].heads,
                               device=x.device)
                )
        
        # Concatenate all relation outputs
        combined = torch.cat(relation_outputs, dim=1)
        
        # Final transformation
        out = F.relu(self.fc1(combined))
        out = self.dropout(out)
        out = self.fc2(out)
        
        return out
    
    def compute_attention_weights(self, x: torch.Tensor, 
                                 edge_index: torch.Tensor) -> torch.Tensor:
        """Compute attention weights between nodes"""
        
        source_nodes = edge_index[0]
        target_nodes = edge_index[1]
        
        source_features = x[source_nodes]
        target_features = x[target_nodes]
        
        # Concatenate source and target features
        combined = torch.cat([source_features, target_features], dim=1)
        
        # Compute attention weights
        attention = self.attention_mlp(combined)
        
        return attention.squeeze()


class CognitiveGraphBuilder:
    """Build graph structure from cognitive test results"""
    
    def __init__(self):
        self.node_types = [
            'concentration', 'calculation', 'simulation',
            'memory', 'attention', 'processing_speed'
        ]
        self.edge_types = {
            'correlation': 0,
            'causation': 1,
            'inhibition': 2,
            'temporal': 3,
            'hierarchical': 4
        }
    
    def build_graph(self, cognitive_scores: Dict[str, List[float]]) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
        """
        Build graph from cognitive scores
        
        Returns:
            node_features: Tensor of node features
            edge_index: Tensor of edge connections
            edge_type: Tensor of edge types
        """
        
        # Create node features from cognitive scores
        node_features = []
        
        for node_type in self.node_types:
            if node_type in cognitive_scores:
                features = cognitive_scores[node_type]
            else:
                # Generate derived features
                features = self._derive_features(node_type, cognitive_scores)
            
            node_features.append(features)
        
        node_features = torch.tensor(node_features, dtype=torch.float32)
        
        # Build edge connections based on cognitive relationships
        edges = []
        edge_types = []
        
        # Concentration -> Attention (correlation)
        edges.append([0, 4])
        edge_types.append(self.edge_types['correlation'])
        
        # Concentration -> Memory (causation)
        edges.append([0, 3])
        edge_types.append(self.edge_types['causation'])
        
        # Calculation -> Processing Speed (correlation)
        edges.append([1, 5])
        edge_types.append(self.edge_types['correlation'])
        
        # Simulation -> All others (hierarchical)
        for i in range(len(self.node_types) - 1):
            if i != 2:  # Skip self-connection
                edges.append([2, i])
                edge_types.append(self.edge_types['hierarchical'])
        
        # Memory <-> Attention (bidirectional correlation)
        edges.append([3, 4])
        edge_types.append(self.edge_types['correlation'])
        edges.append([4, 3])
        edge_types.append(self.edge_types['correlation'])
        
        edge_index = torch.tensor(edges, dtype=torch.long).t()
        edge_type = torch.tensor(edge_types, dtype=torch.long)
        
        return node_features, edge_index, edge_type
    
    def _derive_features(self, node_type: str, 
                        cognitive_scores: Dict[str, List[float]]) -> List[float]:
        """Derive features for nodes without direct scores"""
        
        if node_type == 'memory':
            # Derive from concentration and calculation
            conc = np.mean(cognitive_scores.get('concentration', [0.5]))
            calc = np.mean(cognitive_scores.get('calculation', [0.5]))
            return [0.6 * conc + 0.4 * calc, conc, calc, 0.5]
        
        elif node_type == 'attention':
            # Derive from concentration
            conc = cognitive_scores.get('concentration', [0.5, 0.5, 0.5, 0.5])
            return [c * 0.9 for c in conc]
        
        elif node_type == 'processing_speed':
            # Derive from response times
            return [0.7, 0.6, 0.8, 0.5]  # Placeholder
        
        return [0.5, 0.5, 0.5, 0.5]


class ProgressionPredictor(nn.Module):
    """Predict Alzheimer's progression using R-GAT embeddings"""
    
    def __init__(self, embedding_dim: int = 32, hidden_dim: int = 64):
        super().__init__()
        
        self.lstm = nn.LSTM(embedding_dim, hidden_dim, batch_first=True, num_layers=2)
        self.attention = nn.MultiheadAttention(hidden_dim, num_heads=4)
        
        self.fc_mean = nn.Linear(hidden_dim, 1)
        self.fc_logvar = nn.Linear(hidden_dim, 1)
        
    def forward(self, embeddings: torch.Tensor, 
                temporal_mask: torch.Tensor = None) -> Tuple[torch.Tensor, torch.Tensor]:
        """
        Predict progression trajectory
        
        Args:
            embeddings: R-GAT node embeddings [batch, seq_len, embedding_dim]
            temporal_mask: Mask for temporal attention
            
        Returns:
            mean: Predicted progression mean
            log_variance: Predicted log variance for uncertainty
        """
        
        # LSTM encoding
        lstm_out, (h_n, c_n) = self.lstm(embeddings)
        
        # Self-attention
        if temporal_mask is not None:
            attn_out, _ = self.attention(lstm_out, lstm_out, lstm_out, attn_mask=temporal_mask)
        else:
            attn_out, _ = self.attention(lstm_out, lstm_out, lstm_out)
        
        # Combine LSTM and attention outputs
        combined = lstm_out + attn_out
        
        # Final projection
        mean = self.fc_mean(combined[:, -1, :])
        log_var = self.fc_logvar(combined[:, -1, :])
        
        return mean, log_var`;
            } else if (section === 'api') {
                code = `# OpenAI API Integration for Question Generation and Transfer
import openai
import asyncio
import aiohttp
import json
from typing import List, Dict, Optional
from datetime import datetime
import logging
from sqlalchemy import create_engine, Column, String, Integer, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class Question(Base):
    """Database model for questions"""
    __tablename__ = 'questions'
    
    id = Column(String, primary_key=True)
    module = Column(String, nullable=False)
    difficulty = Column(Integer, nullable=False)
    text = Column(String, nullable=False)
    time_limit = Column(Integer, nullable=False)
    points = Column(Integer, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)


class OpenAIQuestionGenerator:
    """Generate and manage questions using OpenAI API"""
    
    def __init__(self, api_key: str, db_url: str = "sqlite:///questions.db"):
        self.api_key = api_key
        openai.api_key = api_key
        
        # Setup database
        self.engine = create_engine(db_url)
        Base.metadata.create_all(self.engine)
        Session = sessionmaker(bind=self.engine)
        self.session = Session()
        
        # Setup logging
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    async def generate_questions_batch(self, 
                                      module: str, 
                                      difficulty: int, 
                                      count: int) -> List[Dict]:
        """Generate questions asynchronously in batches"""
        
        system_prompts = {
            'concentration': """You are an expert in cognitive assessment for Alzheimer's detection.
                               Generate questions that test attention, focus, and concentration abilities.
                               Each question should be clear, unambiguous, and measurable.""",
            
            'calculation': """You are an expert in mathematical cognitive assessment.
                            Generate arithmetic and calculation problems appropriate for cognitive testing.
                            Include mental math, percentages, and practical calculations.""",
            
            'simulation': """You are an expert in situational judgment and decision-making assessment.
                           Generate realistic scenarios that test problem-solving and judgment.
                           Focus on daily life situations and practical decision-making."""
        }
        
        difficulty_descriptions = {
            1: "Easy - Basic level, simple tasks, clear answers",
            2: "Medium - Moderate complexity, some challenge required",
            3: "Hard - Complex tasks, multiple steps, advanced reasoning"
        }
        
        user_prompt = f"""Generate exactly {count} unique {module} questions.
                          Difficulty: {difficulty_descriptions[difficulty]}
                          
                          Format each question as:
                          Q1: [Question text]
                          Q2: [Question text]
                          ...
                          
                          Make questions appropriate for elderly cognitive assessment.
                          Avoid cultural bias and ensure accessibility."""
        
        try:
            response = await self._async_openai_call(
                system_prompts[module],
                user_prompt
            )
            
            questions = self._parse_generated_questions(
                response, module, difficulty
            )
            
            return questions
            
        except Exception as e:
            self.logger.error(f"Error generating questions: {e}")
            return []
    
    async def _async_openai_call(self, system_prompt: str, user_prompt: str) -> str:
        """Make async call to OpenAI API"""
        
        async with aiohttp.ClientSession() as session:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            data = {
                "model": "gpt-4",
                "messages": [
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                "temperature": 0.8,
                "max_tokens": 3000
            }
            
            async with session.post(
                "https://api.openai.com/v1/chat/completions",
                headers=headers,
                json=data
            ) as response:
                result = await response.json()
                return result['choices'][0]['message']['content']
    
    def _parse_generated_questions(self, 
                                  raw_text: str, 
                                  module: str, 
                                  difficulty: int) -> List[Dict]:
        """Parse GPT output into structured format"""
        
        questions = []
        lines = raw_text.strip().split('\\n')
        
        for i, line in enumerate(lines):
            # Extract question text (remove Q1:, Q2:, etc.)
            if line.strip().startswith('Q'):
                text = line.split(':', 1)[1].strip() if ':' in line else line.strip()
                
                question = {
                    'id': f"{module}_{difficulty}_{datetime.now().timestamp()}_{i}",
                    'module': module,
                    'difficulty': difficulty,
                    'text': text,
                    'time_limit': 30 * difficulty,  # 30s, 60s, 90s
                    'points': 10 * difficulty
                }
                questions.append(question)
        
        return questions
    
    async def generate_full_bank(self) -> Dict:
        """Generate complete 1,500 question bank"""
        
        question_bank = {}
        tasks = []
        
        for module in ['concentration', 'calculation', 'simulation']:
            question_bank[module] = {}
            
            for difficulty in [1, 2, 3]:
                count = 166 if difficulty == 3 else 167
                
                # Create async tasks for parallel generation
                task = self.generate_questions_batch(module, difficulty, count)
                tasks.append((module, difficulty, task))
        
        # Execute all tasks concurrently
        results = await asyncio.gather(*[task for _, _, task in tasks])
        
        # Organize results
        for (module, difficulty, _), questions in zip(tasks, results):
            question_bank[module][difficulty] = questions
            
            # Save to database
            self._save_to_database(questions)
        
        self.logger.info(f"Generated {sum(len(q) for d in question_bank.values() for q in d.values())} questions")
        
        return question_bank
    
    def _save_to_database(self, questions: List[Dict]):
        """Save questions to database"""
        
        for q in questions:
            question_obj = Question(
                id=q['id'],
                module=q['module'],
                difficulty=q['difficulty'],
                text=q['text'],
                time_limit=q['time_limit'],
                points=q['points']
            )
            self.session.merge(question_obj)
        
        self.session.commit()
    
    def get_questions_from_db(self, 
                             module: Optional[str] = None,
                             difficulty: Optional[int] = None) -> List[Dict]:
        """Retrieve questions from database"""
        
        query = self.session.query(Question)
        
        if module:
            query = query.filter(Question.module == module)
        if difficulty:
            query = query.filter(Question.difficulty == difficulty)
        
        questions = query.all()
        
        return [{
            'id': q.id,
            'module': q.module,
            'difficulty': q.difficulty,
            'text': q.text,
            'time_limit': q.time_limit,
            'points': q.points
        } for q in questions]
    
    def create_api_endpoint(self):
        """Create FastAPI endpoint for question access"""
        
        from fastapi import FastAPI, HTTPException
        from fastapi.middleware.cors import CORSMiddleware
        
        app = FastAPI()
        
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        @app.get("/api/questions/{module}/{difficulty}")
        async def get_questions(module: str, difficulty: int):
            questions = self.get_questions_from_db(module, difficulty)
            if not questions:
                raise HTTPException(status_code=404, detail="Questions not found")
            return questions
        
        @app.post("/api/generate")
        async def generate_new_questions(module: str, difficulty: int, count: int = 10):
            questions = await self.generate_questions_batch(module, difficulty, count)
            self._save_to_database(questions)
            return {"status": "success", "count": len(questions)}
        
        @app.get("/api/stats")
        async def get_statistics():
            stats = {}
            for module in ['concentration', 'calculation', 'simulation']:
                stats[module] = {}
                for diff in [1, 2, 3]:
                    count = self.session.query(Question).filter(
                        Question.module == module,
                        Question.difficulty == diff
                    ).count()
                    stats[module][diff] = count
            return stats
        
        return app


# Usage Example
async def main():
    generator = OpenAIQuestionGenerator(api_key="your-api-key-here")
    
    # Generate full question bank
    question_bank = await generator.generate_full_bank()
    
    # Export to JSON
    with open('question_bank.json', 'w') as f:
        json.dump(question_bank, f, indent=2)
    
    # Create API
    app = generator.create_api_endpoint()
    
    # Run with uvicorn
    # uvicorn main:app --reload

if __name__ == "__main__":
    asyncio.run(main())`;
            }

            document.getElementById('codeContent').textContent = code;
        }

        // Initialize with question bank generation
        window.onload = function() {
            generateQuestionBank();
            showCode('questionBank');
        };
    </script>
</body>
</html>
